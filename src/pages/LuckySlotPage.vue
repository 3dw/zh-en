<template>
  <q-page
    class="flex flex-center column"
    style="background-color: #f5f5f7; min-height: 100vh; padding: 16px"
  >
    <div v-if="uid === ''" class="text-center q-pa-lg login-container">
      <q-icon name="lock" size="50px" color="grey-5" />
      <p class="text-h6 q-mt-md" style="color: #1a1a1a">è«‹å…ˆç™»å…¥ä»¥ä½¿ç”¨æ‹‰éœ¸æ©Ÿ</p>
      <q-btn color="primary" label="ç™»å…¥" @click="toggleLogin" style="margin-top: 16px" />
    </div>

    <template v-else>
      <div class="text-h4 q-mb-md page-title">ğŸ‰ æ¯å¤©æ‹‰ä¸€æ¬¡ï¼Œå¼·åŒ–è‹±æ–‡åŠ›ï¼</div>

      <q-btn
        color="secondary"
        flat
        class="q-mb-md"
        @click="showRules = !showRules"
        style="border-radius: 8px"
      >
        <q-icon name="info" class="q-mr-xs" />
        {{ showRules ? 'éš±è—éŠæˆ²è¦å‰‡' : 'æŸ¥çœ‹éŠæˆ²è¦å‰‡' }}
      </q-btn>

      <q-slide-transition>
        <div v-show="showRules" class="rules-container q-mb-lg">
          <div class="text-h6 rules-title">ğŸ® Lucky Slot è‹±æ–‡æ‹‰éœ¸æ©Ÿ - éŠæˆ²è¦å‰‡</div>
          <div class="rules-content">
            <p>æ¯å¤©å¯ç© <b>100</b> æ¬¡ï¼Œæ‹‰ä¸‹å³å´æ‰‹æŸ„æˆ–é»æ“Šã€Œæ‹‰éœ¸é–‹å§‹ã€æŒ‰éˆ•é–‹å§‹éŠæˆ²ï¼</p>

            <div class="rules-section">
              <div class="rules-subtitle">ğŸ“Š çµ„åˆçå‹µ</div>
              <div class="combinations-grid">
                <div class="combination-card">
                  <div class="combination-title">3å€‹å‹•è©</div>
                  <div class="combination-example">run, eat, jump</div>
                  <div class="combination-task">ç”¨å…¶ä¸­ä¸€å€‹å‹•è©é€ å¥</div>
                  <div class="combination-points">+3é»</div>
                </div>

                <div class="combination-card">
                  <div class="combination-title">3å€‹åè©</div>
                  <div class="combination-example">guitar, book, computer</div>
                  <div class="combination-task">æè¿°å…¶ä¸­ä¸€å€‹ç‰©å“çš„åŠŸèƒ½</div>
                  <div class="combination-points">+3é»</div>
                </div>

                <div class="combination-card">
                  <div class="combination-title">3å€‹å½¢å®¹è©</div>
                  <div class="combination-example">happy, smart, fast</div>
                  <div class="combination-task">ç”¨å…¶ä¸­ä¸€å€‹æè¿°å¿ƒæƒ…</div>
                  <div class="combination-points">+3é»</div>
                </div>

                <div class="combination-card">
                  <div class="combination-title">ç‰¹æ®Šçµ„åˆ</div>
                  <div class="combination-example">å‹•è© + åè© + ç‰¹æ®Šç¬¦è™Ÿ</div>
                  <div class="combination-task">ç¿»è­¯æŒ‡å®šå¥å­</div>
                  <div class="combination-points">+2é»</div>
                </div>

                <div class="combination-card">
                  <div class="combination-title">é›™ä¸ƒçµ„åˆ</div>
                  <div class="combination-example">å…©å€‹ä¸ƒç¬¦è™Ÿ (7ï¸âƒ£7ï¸âƒ£)</div>
                  <div class="combination-task">å›ç­”è‹±æ–‡å•ç­”é¡Œ</div>
                  <div class="combination-points">+5é»</div>
                </div>

                <div class="combination-card">
                  <div class="combination-title">å¹¸é‹çµ„åˆ</div>
                  <div class="combination-example">ä¸‰å€‹ç‡ˆæ³¡ (ğŸ’¡ğŸ’¡ğŸ’¡)</div>
                  <div class="combination-task">ç²å¾—è‹±æ–‡å°çŸ¥è­˜</div>
                  <div class="combination-points">+1é»</div>
                </div>
              </div>
            </div>

            <div class="rules-section">
              <div class="rules-subtitle">ğŸ† ä»»å‹™èˆ‡çå‹µ</div>
              <ul>
                <li>å®Œæˆä»»å‹™å¾Œå¯ç²å¾—é¡å¤–é»æ•¸</li>
                <li>ç´¯ç©é»æ•¸å¯ç”¨æ–¼è§£é–æ›´å¤šå­¸ç¿’å…§å®¹å’ŒåŠŸèƒ½</li>
                <li>æäº¤ç­”æ¡ˆæ™‚ç³»çµ±æœƒè‡ªå‹•å„²å­˜æ‚¨çš„å­¸ç¿’ç´€éŒ„</li>
              </ul>
            </div>

            <p class="rules-tip">
              ğŸ’¡ å°æç¤ºï¼šæ¯å¤©å …æŒç©æ‹‰éœ¸æ©Ÿèƒ½æœ‰æ•ˆå¢å¼·æ‚¨çš„è‹±æ–‡å–®å­—è¨˜æ†¶åŠ›èˆ‡é‹ç”¨èƒ½åŠ›ï¼
            </p>
          </div>
        </div>
      </q-slide-transition>

      <div class="slot-machine-container">
        <canvas
          ref="slotCanvas"
          class="slot-canvas"
          :width="canvasWidth"
          :height="canvasHeight"
        ></canvas>

        <!-- æ‹‰éœ¸æ©Ÿæ¡¿ -->
        <div
          class="slot-lever"
          :class="{ 'lever-pulled': leverPulled }"
          @click="pullLever"
          v-if="!spinning && canPlay"
        >
          <div class="lever-grip"></div>
          <div class="lever-stick"></div>
          <div class="lever-base"></div>
        </div>
      </div>

      <div v-if="result" class="result-container q-mt-lg">
        <div class="result-title">{{ result.title }}</div>
        <div class="result-description">{{ result.description }}</div>

        <div v-if="result.task" class="task-container">
          <div style="font-weight: 600; margin-bottom: 8px; color: #1a1a1a">ä»Šæ—¥ä»»å‹™ï¼š</div>
          <div>{{ result.task }}</div>

          <div class="task-input-container q-mt-md" v-if="!taskCompleted">
            <!-- å‹•è©é€ å¥ä»»å‹™ -->
            <div v-if="result.title.includes('å‹•è©')">
              <p class="task-instruction">è«‹ä½¿ç”¨ä¸Šæ–¹å‹•è©é€ ä¸€å€‹å®Œæ•´çš„è‹±æ–‡å¥å­ï¼š</p>
              <q-input
                v-model="textTaskAnswer"
                outlined
                type="textarea"
                placeholder="ä¾‹å¦‚ï¼šI run every morning to stay healthy."
                class="task-input"
              />
            </div>

            <!-- åè©åŠŸèƒ½æè¿°ä»»å‹™ -->
            <div v-else-if="result.title.includes('åè©')">
              <p class="task-instruction">è«‹ç”¨è‹±æ–‡æè¿°å…¶ä¸­ä¸€å€‹ç‰©å“çš„åŠŸèƒ½æˆ–ç‰¹é»ï¼š</p>
              <q-input
                v-model="textTaskAnswer"
                outlined
                type="textarea"
                placeholder="ä¾‹å¦‚ï¼šA guitar is a musical instrument that produces sound when you pluck its strings."
                class="task-input"
              />
            </div>

            <!-- å½¢å®¹è©æè¿°ä»»å‹™ -->
            <div v-else-if="result.title.includes('å½¢å®¹è©')">
              <p class="task-instruction">è«‹ç”¨è‹±æ–‡å½¢å®¹ä½ ç¾åœ¨çš„å¿ƒæƒ…æˆ–ä¸€ä»¶äº‹ç‰©ï¼š</p>
              <q-input
                v-model="textTaskAnswer"
                outlined
                type="textarea"
                placeholder="ä¾‹å¦‚ï¼šI feel happy when I listen to my favorite music."
                class="task-input"
              />
            </div>

            <!-- ç‰¹æ®Šçµ„åˆç¿»è­¯ä»»å‹™ -->
            <div v-else-if="result.title.includes('ç‰¹æ®Š')">
              <p class="task-instruction">è«‹ç¿»è­¯ä»¥ä¸‹å¥å­ï¼š</p>
              <div class="translation-text q-mb-md">{{ specialCombinationSentence }}</div>
              <q-input
                v-model="textTaskAnswer"
                outlined
                type="textarea"
                placeholder="è«‹è¼¸å…¥ä¸­æ–‡ç¿»è­¯..."
                class="task-input"
              />
            </div>

            <!-- é›™ä¸ƒå•ç­”é¡Œ -->
            <div v-else-if="result.title.includes('é›™ä¸ƒ')">
              <p class="task-instruction">{{ bonusQuestion }}</p>
              <div class="bonus-options">
                <q-radio
                  v-model="radioTaskAnswer"
                  val="A"
                  :label="bonusOptions.A"
                  class="q-mb-sm"
                />
                <q-radio
                  v-model="radioTaskAnswer"
                  val="B"
                  :label="bonusOptions.B"
                  class="q-mb-sm"
                />
                <q-radio
                  v-model="radioTaskAnswer"
                  val="C"
                  :label="bonusOptions.C"
                  class="q-mb-sm"
                />
                <q-radio v-model="radioTaskAnswer" val="D" :label="bonusOptions.D" />
              </div>
            </div>

            <!-- å¹¸é‹å°çŸ¥è­˜ -->
            <div v-else-if="result.title.includes('å¹¸é‹')">
              <div class="knowledge-card">
                <p class="knowledge-title">{{ knowledgeCard.title }}</p>
                <p class="knowledge-content">{{ knowledgeCard.content }}</p>
                <p class="knowledge-tip">{{ knowledgeCard.tip }}</p>
              </div>
              <q-checkbox
                v-model="checkboxTaskAnswer"
                true-value="true"
                label="æˆ‘å·²é–±è®€ä¸¦ç†è§£é€™å€‹å°çŸ¥è­˜"
              />
            </div>

            <div class="task-actions q-mt-md">
              <q-btn
                color="primary"
                :disable="!isTaskAnswerValid"
                @click="submitTask"
                style="border-radius: 8px"
              >
                æäº¤ç­”æ¡ˆ
              </q-btn>
            </div>
          </div>

          <div v-else class="task-completed-container q-mt-md">
            <div class="task-completed-message">
              <q-icon name="check_circle" color="positive" size="24px" class="q-mr-sm" />
              ä»»å‹™å·²å®Œæˆï¼
            </div>
            <div class="task-feedback q-mt-sm" v-if="taskFeedback">
              {{ taskFeedback }}
            </div>
          </div>
        </div>

        <div class="points-container">
          <q-icon name="stars" color="primary" size="24px" class="q-mr-sm" />
          ç²å¾— {{ result.points }} é»
        </div>
      </div>

      <div class="q-mt-lg action-buttons">
        <q-btn
          color="primary"
          :disable="!canPlay || spinning"
          @click="pullLever"
          class="action-button"
        >
          {{ spinning ? 'æ—‹è½‰ä¸­...' : canPlay ? 'æ‹‰éœ¸é–‹å§‹ï¼' : 'ä»Šæ—¥å·²ç©é' }}
        </q-btn>

        <q-btn color="secondary" @click="forceRedraw" class="action-button"> é‡ç¹ªç•«é¢ </q-btn>
      </div>
    </template>
  </q-page>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onUnmounted, computed, nextTick, watch } from 'vue'
import { getDatabase, ref as dbRef, get, set, serverTimestamp, push } from 'firebase/database'

// ç¬¦è™Ÿé¡å‹å®šç¾©
interface Symbol {
  type: string // 'verb', 'noun', 'adjective', 'emoji', 'special'
  value: string // å–®å­—æˆ–ç¬¦è™Ÿæ–‡å­—å€¼
  emoji: string // å±•ç¤ºçš„è¡¨æƒ…ç¬¦è™Ÿ
  category: string // åˆ†é¡
  text: string // é¡¯ç¤ºçš„æ–‡å­— (ç”¨æ–¼ç¹ªè£½)
}

// è½‰è¼ªå®šç¾©
interface Reel {
  position: number
  finalPosition: number
  spinning: boolean
  symbols: Symbol[]
}

// çµæœå®šç¾©
interface Result {
  title: string
  description: string
  task?: string | undefined
  points: number
}

export default defineComponent({
  name: 'LuckySlotPage',
  props: {
    uid: {
      type: String,
      default: '',
    },
  },
  setup(props, { emit }) {
    // åŸºæœ¬åƒæ•¸è¨­å®š
    const slotCanvas = ref<HTMLCanvasElement | null>(null)
    const ctx = ref<CanvasRenderingContext2D | null>(null)
    const canPlay = ref(true)
    const spinning = ref(false)
    const leverPulled = ref(false)
    const result = ref<Result | null>(null)
    const showRules = ref(false)

    // ä»»å‹™ç›¸é—œåƒæ•¸
    const textTaskAnswer = ref('')
    const radioTaskAnswer = ref('')
    const checkboxTaskAnswer = ref(false)
    const taskCompleted = ref(false)
    const taskFeedback = ref('')
    const specialCombinationSentence = ref('')
    const bonusQuestion = ref('')
    const bonusOptions = ref({
      A: '',
      B: '',
      C: '',
      D: '',
    })
    const bonusCorrectAnswer = ref('')
    const knowledgeCard = ref({
      title: '',
      content: '',
      tip: '',
    })

    // æª¢æŸ¥ä»»å‹™ç­”æ¡ˆæ˜¯å¦æœ‰æ•ˆ
    const isTaskAnswerValid = computed(() => {
      if (!result.value || !result.value.task) return false

      // å„ç¨®ä»»å‹™çš„æœ‰æ•ˆæ€§æª¢æŸ¥
      if (
        result.value.title.includes('å‹•è©') ||
        result.value.title.includes('åè©') ||
        result.value.title.includes('å½¢å®¹è©') ||
        result.value.title.includes('ç‰¹æ®Š')
      ) {
        // æ–‡å­—é¡ä»»å‹™è‡³å°‘éœ€è¦10å€‹å­—ç¬¦
        return textTaskAnswer.value.trim().length >= 10
      } else if (result.value.title.includes('é›™ä¸ƒ')) {
        // é¸æ“‡é¡Œéœ€è¦é¸æ“‡ä¸€å€‹é¸é …
        return ['A', 'B', 'C', 'D'].includes(radioTaskAnswer.value)
      } else if (result.value.title.includes('å¹¸é‹')) {
        // çŸ¥è­˜å¡ç‰‡éœ€è¦å‹¾é¸é–±è®€ç¢ºèª
        return Boolean(checkboxTaskAnswer.value) === true
      }

      return false
    })

    // ç¬¦è™Ÿåº«ï¼šæ ¹æ“šä¼åŠƒè¦æ±‚è¨­å®šä¸åŒé¡å‹çš„ç¬¦è™Ÿ
    const symbols: Symbol[] = [
      // å‹•è©
      { type: 'verb', value: 'run', emoji: 'ğŸƒ', category: 'é‹å‹•', text: 'run' },
      { type: 'verb', value: 'eat', emoji: 'ğŸ½ï¸', category: 'é£²é£Ÿ', text: 'eat' },
      { type: 'verb', value: 'jump', emoji: 'ğŸ¦˜', category: 'é‹å‹•', text: 'jump' },
      { type: 'verb', value: 'play', emoji: 'ğŸ®', category: 'å¨›æ¨‚', text: 'play' },
      { type: 'verb', value: 'sing', emoji: 'ğŸ¤', category: 'éŸ³æ¨‚', text: 'sing' },

      // åè©
      { type: 'noun', value: 'guitar', emoji: 'ğŸ¸', category: 'éŸ³æ¨‚', text: 'guitar' },
      { type: 'noun', value: 'book', emoji: 'ğŸ“š', category: 'æ ¡åœ’', text: 'book' },
      { type: 'noun', value: 'computer', emoji: 'ğŸ’»', category: 'ç§‘æŠ€', text: 'computer' },
      { type: 'noun', value: 'ball', emoji: 'âš½', category: 'é‹å‹•', text: 'ball' },
      { type: 'noun', value: 'fruit', emoji: 'ğŸ', category: 'é£²é£Ÿ', text: 'fruit' },

      // å½¢å®¹è©
      { type: 'adjective', value: 'happy', emoji: 'ğŸ˜Š', category: 'æƒ…ç·’', text: 'happy' },
      { type: 'adjective', value: 'smart', emoji: 'ğŸ§ ', category: 'ç‰¹è³ª', text: 'smart' },
      { type: 'adjective', value: 'fast', emoji: 'âš¡', category: 'ç‰¹è³ª', text: 'fast' },
      { type: 'adjective', value: 'big', emoji: 'ğŸ“', category: 'å¤§å°', text: 'big' },
      { type: 'adjective', value: 'sweet', emoji: 'ğŸ­', category: 'å‘³é“', text: 'sweet' },

      // ç‰¹æ®Šç¬¦è™Ÿ
      { type: 'special', value: 'seven', emoji: '7ï¸âƒ£', category: 'ç‰¹æ®Š', text: '7ï¸âƒ£' },
      { type: 'special', value: 'light', emoji: 'ğŸ’¡', category: 'ç‰¹æ®Š', text: 'ğŸ’¡' },
      { type: 'special', value: 'music', emoji: 'ğŸµ', category: 'ç‰¹æ®Š', text: 'ğŸµ' },
    ]

    // åˆå§‹åŒ–ä¸‰å€‹è½‰è¼ª
    const reels = ref<Reel[]>([
      { position: 0, finalPosition: 0, spinning: false, symbols: [] },
      { position: 0, finalPosition: 0, spinning: false, symbols: [] },
      { position: 0, finalPosition: 0, spinning: false, symbols: [] },
    ])

    // æ‹‰éœ¸æ©Ÿé¡è‰²è¨­å®š
    const slotMachineColors = {
      body: '#ffffff',
      frame: '#0070ff',
      reelBackground: '#f5f8ff',
      reelBorder: '#e6e6eb',
      reelSeparator: '#e6e6eb',
      symbolBackground: '#ffffff',
    }

    // æ–°å¢éŸ¿æ‡‰å¼ Canvas å°ºå¯¸
    const canvasWidth = ref(600)
    const canvasHeight = ref(400)

    // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
    const updateCanvasSize = () => {
      const width = window.innerWidth
      if (width <= 600) {
        canvasWidth.value = width - 32 // æ¸›å»å·¦å³padding
        canvasHeight.value = (canvasWidth.value * 2) / 3 // ä¿æŒ 3:2 æ¯”ä¾‹
      } else {
        canvasWidth.value = 600
        canvasHeight.value = 400
      }

      // é‡æ–°åˆå§‹åŒ– Canvas
      nextTick(() => {
        if (slotCanvas.value) {
          initCanvas()
        }
      })
    }

    // åˆå§‹åŒ–Canvas
    const initCanvas = () => {
      if (!slotCanvas.value) {
        console.error('Canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œå°‡åœ¨100mså¾Œé‡è©¦')
        setTimeout(() => {
          if (slotCanvas.value) {
            initCanvas()
          }
        }, 100)
        return
      }

      ctx.value = slotCanvas.value.getContext('2d')
      if (!ctx.value) {
        console.error('ç„¡æ³•ç²å–Canvas context')
        return
      }

      console.log('Canvas context å»ºç«‹æˆåŠŸ')

      // åˆå§‹åŒ–è½‰è¼ªç¬¦è™Ÿ
      for (let i = 0; i < reels.value.length; i++) {
        const reel = reels.value[i]
        if (reel) {
          const verbSymbols = symbols.filter((s) => s.type === 'verb')
          const nounSymbols = symbols.filter((s) => s.type === 'noun')
          const adjSymbols = symbols.filter((s) => s.type === 'adjective')
          const specialSymbols = symbols.filter((s) => s.type === 'special')

          const allSymbols = [...verbSymbols, ...nounSymbols, ...adjSymbols, ...specialSymbols]
          reel.symbols = allSymbols.sort(() => Math.random() - 0.5)
          reel.position = Math.floor(Math.random() * reel.symbols.length)
          console.log(`è¼ªç›¤ ${i} åˆå§‹åŒ–äº† ${reel.symbols.length} å€‹ç¬¦è™Ÿ`)
        }
      }

      // ç«‹å³ç¹ªè£½åˆå§‹ç•«é¢
      drawSlotMachine()
    }

    // ç¹ªè£½æ‹‰éœ¸æ©Ÿ
    const drawSlotMachine = () => {
      if (!ctx.value || !slotCanvas.value) {
        console.error('ç„¡æ³•ç¹ªè£½æ‹‰éœ¸æ©Ÿï¼šCanvasæˆ–Contextä¸å­˜åœ¨')
        return
      }

      console.log('é–‹å§‹ç¹ªè£½æ‹‰éœ¸æ©Ÿ')

      const canvas = slotCanvas.value
      const context = ctx.value
      const isMobile = window.innerWidth <= 600

      // æ¸…ç©ºç•«å¸ƒ
      context.clearRect(0, 0, canvas.width, canvas.height)

      if (!isMobile) {
        // æ¡Œé¢ç‰ˆï¼šç¹ªè£½å®Œæ•´æ‹‰éœ¸æ©Ÿ
        // ç¹ªè£½æ©Ÿå™¨ä¸»é«” - åœ“è§’çŸ©å½¢èƒŒæ™¯
        roundRect(context, 50, 50, 500, 300, 12, slotMachineColors.body, false)

        // ç¹ªè£½æ©Ÿå™¨æ¡†æ¶
        context.strokeStyle = slotMachineColors.frame
        context.lineWidth = 3
        roundRect(context, 50, 50, 500, 300, 12, null, true)

        // ç¹ªè£½æ¨™é¡Œ
        context.fillStyle = '#1a1a1a'
        context.font = 'bold 24px Arial'
        context.textAlign = 'center'
        context.fillText('Lucky English Slot', canvas.width / 2, 35)
      }

      // è¨ˆç®—æ¯å€‹è½‰è¼ªçš„å¯¬åº¦å’Œé«˜åº¦
      const reelWidth = isMobile ? canvas.width / 3.5 : 120
      const reelHeight = isMobile ? canvas.height * 0.8 : 200
      const startX = isMobile
        ? (canvas.width - (reelWidth * 3 + 40)) / 2
        : canvas.width / 2 - reelWidth * 1.5 - 20
      const startY = isMobile ? canvas.height * 0.1 : 100

      // ç¹ªè£½ä¸‰å€‹è½‰è¼ª
      for (let i = 0; i < reels.value.length; i++) {
        // è¨ˆç®—è½‰è¼ªçš„Xåº§æ¨™
        const reelX = startX + i * (reelWidth + (isMobile ? 10 : 20))

        if (!isMobile) {
          // æ¡Œé¢ç‰ˆï¼šç¹ªè£½è½‰è¼ªèƒŒæ™¯
          roundRect(
            context,
            reelX,
            startY,
            reelWidth,
            reelHeight,
            8,
            slotMachineColors.reelBackground,
            false,
          )
          context.strokeStyle = slotMachineColors.reelBorder
          context.lineWidth = 2
          roundRect(context, reelX, startY, reelWidth, reelHeight, 8, null, true)
        }

        // ç¹ªè£½ç¬¦è™Ÿ
        const reel = reels.value[i]
        if (reel && reel.symbols.length > 0) {
          const symbolHeight = reelHeight / 3

          // ç¹ªè£½ä¸‰å€‹ä½ç½®çš„ç¬¦è™Ÿ (ä¸Šã€ä¸­ã€ä¸‹)
          for (let j = -1; j <= 1; j++) {
            const symbolIndex = (reel.position + j + reel.symbols.length) % reel.symbols.length
            const symbol = reel.symbols[symbolIndex]

            const symbolY = startY + (j + 1) * symbolHeight

            // ç¹ªè£½ç¬¦è™ŸèƒŒæ™¯ (åœ“å½¢)
            context.fillStyle = slotMachineColors.symbolBackground
            context.beginPath()
            context.arc(
              reelX + reelWidth / 2,
              symbolY + symbolHeight / 2,
              symbolHeight / 2 - (isMobile ? 2 : 5),
              0,
              Math.PI * 2,
            )
            context.fill()
            context.strokeStyle = '#0070ff'
            context.lineWidth = isMobile ? 0.5 : 1
            context.stroke()

            // ç¹ªè£½ç¬¦è™Ÿ (æ–‡å­—)
            context.fillStyle = j === 0 ? '#0070ff' : '#666666'
            context.font =
              j === 0
                ? isMobile
                  ? 'bold 16px Arial'
                  : 'bold 24px Arial'
                : isMobile
                  ? '14px Arial'
                  : '20px Arial'
            context.textAlign = 'center'
            context.textBaseline = 'middle'

            // æ ¹æ“šç¬¦è™Ÿé¡å‹è¨­å®šé¡è‰²
            if (symbol && j === 0) {
              if (symbol.type === 'verb') context.fillStyle = '#0070ff'
              else if (symbol.type === 'noun') context.fillStyle = '#FF9500'
              else if (symbol.type === 'adjective') context.fillStyle = '#34C759'
              else if (symbol.type === 'special') context.fillStyle = '#AF52DE'
            }

            if (symbol && symbol.text) {
              context.fillText(symbol.text, reelX + reelWidth / 2, symbolY + symbolHeight / 2)
            } else if (symbol) {
              context.fillText(symbol.value, reelX + reelWidth / 2, symbolY + symbolHeight / 2)
            }
          }
        }
      }

      if (!isMobile) {
        // æ¡Œé¢ç‰ˆï¼šç¹ªè£½åº•éƒ¨æ§åˆ¶å€
        context.fillStyle = '#f5f8ff'
        roundRect(context, 100, startY + reelHeight + 20, 400, 50, 8, '#f5f8ff', false)

        context.fillStyle = '#1a1a1a'
        context.font = '16px Arial'
        context.textAlign = 'center'
        context.textBaseline = 'middle'
        context.fillText(
          spinning.value ? 'æ—‹è½‰ä¸­...' : canPlay.value ? 'æ‹‰ä¸‹å³å´æ‰‹æŸ„é–‹å§‹' : 'ä»Šæ—¥å·²ç©é',
          canvas.width / 2,
          startY + reelHeight + 45,
        )
      }
    }

    // ç¹ªè£½åœ“è§’çŸ©å½¢çš„è¼”åŠ©å‡½æ•¸
    const roundRect = (
      ctx: CanvasRenderingContext2D,
      x: number,
      y: number,
      width: number,
      height: number,
      radius: number,
      fill?: string | null,
      stroke?: boolean,
    ): void => {
      if (typeof radius === 'undefined') radius = 5
      ctx.beginPath()
      ctx.moveTo(x + radius, y)
      ctx.lineTo(x + width - radius, y)
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius)
      ctx.lineTo(x + width, y + height - radius)
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)
      ctx.lineTo(x + radius, y + height)
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius)
      ctx.lineTo(x, y + radius)
      ctx.quadraticCurveTo(x, y, x + radius, y)
      ctx.closePath()
      if (fill) {
        ctx.fillStyle = fill
        ctx.fill()
      }
      if (stroke) {
        ctx.stroke()
      }
    }

    // æ‹‰å‹•æ‹‰éœ¸æ©Ÿ
    const pullLever = () => {
      if (spinning.value || !canPlay.value || props.uid === '') return

      leverPulled.value = true
      spinning.value = true
      result.value = null

      // æª¢æŸ¥æ¯æ—¥é™åˆ¶
      checkDailyLimit().then((canContinue) => {
        if (!canContinue) {
          spinning.value = false
          leverPulled.value = false
          return
        }

        // é–‹å§‹æ—‹è½‰å‹•ç•«
        spinReels()

        // æ‹‰æ¡¿å‹•ç•«çµæŸå¾Œå›å½ˆ
        setTimeout(() => {
          leverPulled.value = false
        }, 1000)
      })
    }

    // æª¢æŸ¥æ¯æ—¥é™åˆ¶
    const checkDailyLimit = async () => {
      if (props.uid === '') return false

      const db = getDatabase()
      const userRef = dbRef(db, `users/${props.uid}`)
      const snapshot = await get(userRef)

      const today = new Date().toDateString()
      let playCount = 0
      let lastPlayDate = ''

      if (snapshot.exists()) {
        const userData = snapshot.val()
        playCount = userData.playCount || 0
        lastPlayDate = userData.lastPlayDate || ''
      }

      if (lastPlayDate === today) {
        if (playCount >= 100) {
          // æ¯å¤©å¯ä»¥ç©100æ¬¡
          canPlay.value = false
          alert('ä»Šå¤©å·²ç¶“ç©æ»¿100æ¬¡äº†ï¼Œæ˜å¤©å†ä¾†å§ï¼')
          return false
        }
        playCount += 1
      } else {
        // æ–°çš„ä¸€å¤©ï¼Œé‡è¨­è¨ˆæ•¸
        playCount = 1
        lastPlayDate = today
      }

      // æ›´æ–°éŠæˆ²æ¬¡æ•¸å’Œæ—¥æœŸ
      await set(dbRef(db, `users/${props.uid}/playCount`), playCount)
      await set(dbRef(db, `users/${props.uid}/lastPlayDate`), lastPlayDate)
      await set(dbRef(db, `users/${props.uid}/lastPlay`), serverTimestamp())

      return true
    }

    // è½‰å‹•è½‰è¼ª
    const spinReels = () => {
      // æ±ºå®šæœ€çµ‚çµæœ
      const finalPositions = determineResult()

      // è¨­å®šæ¯å€‹è½‰è¼ªçš„æœ€çµ‚ä½ç½®
      for (let i = 0; i < reels.value.length; i++) {
        const reel = reels.value[i]
        if (reel && i < finalPositions.length && finalPositions[i] !== undefined) {
          reel.finalPosition = finalPositions[i] as number
          reel.spinning = true
        }
      }

      // é–‹å§‹å‹•ç•«
      let frames = 0
      const maxFrames = 60 // ç¸½å¹€æ•¸
      const animationDuration = 3000 // ç¸½å‹•ç•«æ™‚é–“ (ms)
      const frameInterval = animationDuration / maxFrames

      // è¨­å®šæ¯å€‹è½‰è¼ªåœæ­¢çš„æ™‚é–“å·® (ç¬¬ä¸€å€‹æœ€å¿«åœï¼Œç¬¬ä¸‰å€‹æœ€æ…¢åœ)
      const stopFrames = [
        Math.floor(maxFrames * 0.6), // ç¬¬ä¸€å€‹è½‰è¼ªåœæ­¢çš„å¹€æ•¸
        Math.floor(maxFrames * 0.8), // ç¬¬äºŒå€‹è½‰è¼ªåœæ­¢çš„å¹€æ•¸
        maxFrames, // ç¬¬ä¸‰å€‹è½‰è¼ªåœæ­¢çš„å¹€æ•¸
      ]

      const animate = () => {
        frames++

        // æ›´æ–°è½‰è¼ªä½ç½®
        for (let i = 0; i < reels.value.length; i++) {
          const reel = reels.value[i]
          if (!reel) continue

          const stopFrame = stopFrames[i]
          if (stopFrame !== undefined && frames < stopFrame) {
            // é‚„åœ¨æ—‹è½‰
            reel.position = (reel.position + 1) % reel.symbols.length
          } else if (stopFrame !== undefined && frames === stopFrame) {
            // é–‹å§‹æ¸›é€Ÿä¸¦åœåœ¨æŒ‡å®šä½ç½®
            reel.position = reel.finalPosition
            reel.spinning = false

            // æ’­æ”¾åœæ­¢éŸ³æ•ˆ (å¦‚æœæœ‰)
            playStopSound()
          }
        }

        // é‡ç¹ªæ‹‰éœ¸æ©Ÿ
        drawSlotMachine()

        // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è½‰è¼ªéƒ½åœæ­¢äº†
        if (frames < maxFrames) {
          // é‚„æœ‰è½‰è¼ªåœ¨æ—‹è½‰ï¼Œç¹¼çºŒå‹•ç•«
          setTimeout(() => {
            requestAnimationFrame(animate)
          }, frameInterval)
        } else {
          // æ‰€æœ‰è½‰è¼ªéƒ½åœæ­¢äº†ï¼Œé¡¯ç¤ºçµæœ
          spinning.value = false
          showResult()
        }
      }

      // é–‹å§‹å‹•ç•«
      animate()
    }

    // æ’­æ”¾åœæ­¢éŸ³æ•ˆ (å¯é¸åŠŸèƒ½)
    const playStopSound = () => {
      // å¦‚æœæœ‰éŸ³æ•ˆè³‡æºï¼Œå¯ä»¥åœ¨é€™è£¡æ’­æ”¾
      // const audio = new Audio('path/to/stop-sound.mp3');
      // audio.play();
    }

    // æ±ºå®šæœ€çµ‚çµæœ (å¯ä»¥æ ¹æ“šæ¦‚ç‡æˆ–å…¶ä»–é‚è¼¯ä¾†æ±ºå®š)
    const determineResult = (): number[] => {
      // åœ¨é€™å€‹ç¤ºä¾‹ä¸­ï¼Œæˆ‘å€‘æŒ‡å®šä¸‰å€‹è½‰è¼ªçš„æœ€çµ‚ä½ç½®
      // é€™è£¡å¯ä»¥æ ¹æ“šéœ€è¦å¯¦ç¾ä¸åŒçš„é‚è¼¯ï¼Œä¾‹å¦‚ï¼š
      // 1. å®Œå…¨éš¨æ©Ÿ
      // 2. æ ¹æ“šæ©Ÿç‡è¡¨æ±ºå®šçé …
      // 3. æŒ‡å®šç‰¹å®šçµ„åˆ

      // ç¤ºä¾‹ï¼šéš¨æ©Ÿæ±ºå®šæœ€çµ‚ä½ç½®
      const positions: number[] = reels.value.map((reel) =>
        reel ? Math.floor(Math.random() * reel.symbols.length) : 0,
      )

      // æ§åˆ¶çµ„åˆæ©Ÿç‡ (å¯é¸)
      const random = Math.random()

      // æ©Ÿç‡æ±ºå®šå‡ºç‰¹æ®Šçµ„åˆ
      if (random < 0.1) {
        // 10% æ©Ÿç‡å‡ºç¾ä¸‰å€‹å‹•è©
        const verbPositions: number[] = []
        for (let i = 0; i < reels.value.length; i++) {
          const reel = reels.value[i]
          if (reel) {
            const verbIndex = reel.symbols.findIndex((s) => s.type === 'verb')
            verbPositions.push(verbIndex >= 0 ? verbIndex : positions[i] || 0)
          } else {
            verbPositions.push(0)
          }
        }
        return verbPositions
      } else if (random < 0.2) {
        // 10% æ©Ÿç‡å‡ºç¾ä¸€å‹•è©+ä¸€åè©+ä¸€emoji
        const reel0 = reels.value[0]
        const reel1 = reels.value[1]
        const reel2 = reels.value[2]

        const indices: number[] = [
          reel0 && reel0.symbols ? reel0.symbols.findIndex((s) => s.type === 'verb') : -1,
          reel1 && reel1.symbols ? reel1.symbols.findIndex((s) => s.type === 'noun') : -1,
          reel2 && reel2.symbols ? reel2.symbols.findIndex((s) => s.type === 'special') : -1,
        ]
        return indices.map((idx) => (idx >= 0 ? idx : Math.floor(Math.random() * symbols.length)))
      } else if (random < 0.25) {
        // 5% æ©Ÿç‡å‡ºç¾é›™ä¸ƒ
        const sevenIndex = symbols.findIndex((s) => s.emoji === '7ï¸âƒ£')
        if (sevenIndex >= 0) {
          positions[0] = sevenIndex
          positions[1] = sevenIndex
        }
      }

      return positions
    }

    // é¡¯ç¤ºçµæœ
    const showResult = async () => {
      if (props.uid === '') return

      // ç²å–æœ€çµ‚çµæœ
      const finalSymbols: (Symbol | undefined)[] = reels.value.map((reel) =>
        reel ? reel.symbols[reel.position] : undefined,
      )

      // æª¢æŸ¥æ˜¯å¦æœ‰ undefined çš„ç¬¦è™Ÿ
      const validSymbols = finalSymbols.every((s) => s !== undefined)
      if (!validSymbols) {
        console.error('Invalid symbols found in result')
        return
      }

      // æª¢æŸ¥çµ„åˆä¸¦æ±ºå®šçå‹µ
      let resultTitle = 'å†æ¥å†å²ï¼'
      let resultDescription = 'ä¸‹æ¬¡å†ä¾†è©¦è©¦çœ‹å§ï¼'
      let resultTask = undefined
      let points = 0

      // å‹•è©çµ„åˆ
      const allVerbs = finalSymbols.every((s) => s?.type === 'verb')
      if (allVerbs) {
        resultTitle = 'å‹•è©çµ„åˆï¼'
        resultDescription = `ä½ æŠ½åˆ°äº†ï¼š${finalSymbols.map((s) => s?.value).join(', ')}`
        resultTask = 'è«‹ç”¨å…¶ä¸­ä¸€å€‹å‹•è©é€ å¥'
        points = 3
      }
      // åè©çµ„åˆ
      else if (finalSymbols.every((s) => s?.type === 'noun')) {
        resultTitle = 'åè©çµ„åˆï¼'
        resultDescription = `ä½ æŠ½åˆ°äº†ï¼š${finalSymbols.map((s) => s?.value).join(', ')}`
        resultTask = 'è«‹æè¿°å…¶ä¸­ä¸€å€‹ç‰©å“çš„åŠŸèƒ½'
        points = 3
      }
      // å½¢å®¹è©çµ„åˆ
      else if (finalSymbols.every((s) => s?.type === 'adjective')) {
        resultTitle = 'å½¢å®¹è©çµ„åˆï¼'
        resultDescription = `ä½ æŠ½åˆ°äº†ï¼š${finalSymbols.map((s) => s?.value).join(', ')}`
        resultTask = 'è«‹ç”¨å…¶ä¸­ä¸€å€‹å½¢å®¹è©æè¿°ä½ çš„å¿ƒæƒ…'
        points = 3
      }
      // ç‰¹æ®Šçµ„åˆï¼šå‹•è©+åè©+emoji
      else if (
        finalSymbols.some((s) => s?.type === 'verb') &&
        finalSymbols.some((s) => s?.type === 'noun') &&
        finalSymbols.some((s) => s?.type === 'special')
      ) {
        resultTitle = 'ç‰¹æ®Šçµ„åˆï¼'
        resultDescription = `ä½ æŠ½åˆ°äº†ï¼š${finalSymbols.map((s) => s?.value).join(', ')}`
        resultTask = 'è«‹ç¿»è­¯é€™çµ„æ­é…çš„å¥å­'
        points = 2
      }
      // é›™ä¸ƒçµ„åˆ
      else if (finalSymbols.filter((s) => s?.emoji === '7ï¸âƒ£').length >= 2) {
        resultTitle = 'é›™ä¸ƒçµ„åˆï¼'
        resultDescription = 'æ­å–œç²å¾— Bonus å•ç­”é¡Œï¼'
        resultTask = 'é–‹å§‹å•ç­”'
        points = 5
      }
      // ä¸‰å€‹ç‡ˆæ³¡
      else if (finalSymbols.every((s) => s?.emoji === 'ğŸ’¡')) {
        resultTitle = 'å¹¸é‹çµ„åˆï¼'
        resultDescription = 'ä½ ç²å¾—äº†çŸ¥è­˜å°å¡ç‰‡ï¼'
        resultTask = 'æŸ¥çœ‹å°çŸ¥è­˜'
        points = 1
      }

      // è¨­å®šçµæœ
      const resultData: Result = {
        title: resultTitle,
        description: resultDescription,
        points: points,
      }

      if (resultTask) {
        resultData.task = resultTask
      }

      result.value = resultData

      // é‡ç½®ä»»å‹™ç‹€æ…‹
      textTaskAnswer.value = ''
      radioTaskAnswer.value = ''
      checkboxTaskAnswer.value = false
      taskCompleted.value = false
      taskFeedback.value = ''

      // æº–å‚™ä»»å‹™å…§å®¹
      if (resultTask) {
        prepareTasks(finalSymbols.filter((s): s is Symbol => s !== undefined))
      }

      // å„²å­˜éŠæˆ²è¨˜éŒ„åˆ°è³‡æ–™åº«
      await saveGameRecord(
        finalSymbols.filter((s): s is Symbol => s !== undefined),
        points,
      )
    }

    // æº–å‚™ä¸åŒé¡å‹çš„ä»»å‹™å…§å®¹
    const prepareTasks = (symbols: Symbol[]) => {
      if (!result.value || !result.value.title) return

      // æ ¹æ“šçµæœé¡å‹æº–å‚™ä¸åŒçš„ä»»å‹™
      if (result.value.title.includes('ç‰¹æ®Š')) {
        // ç‰¹æ®Šçµ„åˆï¼šç”Ÿæˆä¸€å€‹å¥å­ä¾›ç”¨æˆ¶ç¿»è­¯
        const verb = symbols.find((s) => s.type === 'verb')?.value || ''
        const noun = symbols.find((s) => s.type === 'noun')?.value || ''
        const special = symbols.find((s) => s.type === 'special')?.emoji || ''

        specialCombinationSentence.value = `I ${verb} the ${noun} when I see ${special}.`
      } else if (result.value.title.includes('é›™ä¸ƒ')) {
        // é›™ä¸ƒå•ç­”é¡Œï¼šå¾è³‡æ–™åº«ç²å–ä¸€å€‹éš¨æ©Ÿå•é¡Œ
        fetchBonusQuestion()
      } else if (result.value.title.includes('å¹¸é‹')) {
        // å¹¸é‹å°çŸ¥è­˜ï¼šæº–å‚™ä¸€å€‹è‹±æ–‡å°çŸ¥è­˜å¡ç‰‡
        prepareKnowledgeCard()
      }
    }

    // ç²å–éš¨æ©Ÿå•ç­”é¡Œ
    const fetchBonusQuestion = async () => {
      try {
        const db = getDatabase()
        const questionsRef = dbRef(db, 'bonusQuestions')
        const snapshot = await get(questionsRef)

        if (snapshot.exists()) {
          const questions = snapshot.val()
          const keys = Object.keys(questions)
          if (keys.length > 0) {
            const randomKey = keys[Math.floor(Math.random() * keys.length)]
            const question = questions[randomKey as keyof typeof questions]

            bonusQuestion.value = question.question
            bonusOptions.value = question.options
            bonusCorrectAnswer.value = question.answer
          } else {
            useDefaultBonusQuestion()
          }
        } else {
          useDefaultBonusQuestion()
        }
      } catch (error) {
        console.error('ç²å–å•ç­”é¡Œå¤±æ•—:', error)
        useDefaultBonusQuestion()
      }
    }

    // ä½¿ç”¨é»˜èªå•ç­”é¡Œ
    const useDefaultBonusQuestion = () => {
      bonusQuestion.value = 'Which of these is NOT a part of speech in English?'
      bonusOptions.value = {
        A: 'Noun',
        B: 'Adjective',
        C: 'Transitive',
        D: 'Adverb',
      }
      bonusCorrectAnswer.value = 'C'
    }

    // æº–å‚™çŸ¥è­˜å¡ç‰‡
    const prepareKnowledgeCard = async () => {
      try {
        const db = getDatabase()
        const cardsRef = dbRef(db, 'knowledgeCards')
        const snapshot = await get(cardsRef)

        if (snapshot.exists()) {
          const cards = snapshot.val()
          const keys = Object.keys(cards)
          if (keys.length > 0) {
            const randomKey = keys[Math.floor(Math.random() * keys.length)]
            const card = cards[randomKey as keyof typeof cards]

            knowledgeCard.value = card
          } else {
            useDefaultKnowledgeCard()
          }
        } else {
          useDefaultKnowledgeCard()
        }
      } catch (error) {
        console.error('ç²å–çŸ¥è­˜å¡ç‰‡å¤±æ•—:', error)
        useDefaultKnowledgeCard()
      }
    }

    // ä½¿ç”¨é»˜èªçŸ¥è­˜å¡ç‰‡
    const useDefaultKnowledgeCard = () => {
      knowledgeCard.value = {
        title: 'è‹±æ–‡å­¸ç¿’å°æŠ€å·§',
        content:
          'ç ”ç©¶è¡¨æ˜ï¼Œæ¯å¤©å­¸ç¿’10-15å€‹æ–°å–®è©ä¸¦ç«‹å³ä½¿ç”¨å®ƒå€‘é€ å¥ï¼Œèƒ½å¤ é¡¯è‘—æé«˜ä½ çš„è©å½™é‡å’Œè¨˜æ†¶æ•ˆæœã€‚',
        tip: 'å˜—è©¦åœ¨æ—¥å¸¸ç”Ÿæ´»ä¸­å°‹æ‰¾æ©Ÿæœƒä½¿ç”¨æ–°å­¸çš„å–®è©ï¼Œé€™æ¨£èƒ½å¤ æ›´å¥½åœ°éå›ºè¨˜æ†¶ã€‚',
      }
    }

    // æäº¤ä»»å‹™ç­”æ¡ˆ
    const submitTask = async () => {
      if (props.uid === '' || !result.value || !isTaskAnswerValid.value) return

      try {
        // å„²å­˜ä»»å‹™å®Œæˆè¨˜éŒ„
        const db = getDatabase()

        let correct = true
        let extraPoints = 0
        let answerValue: string | boolean = ''

        // æ ¹æ“šä»»å‹™é¡å‹ç¢ºå®šç­”æ¡ˆå€¼å’Œé©—è­‰ç­”æ¡ˆ
        if (
          result.value.title.includes('å‹•è©') ||
          result.value.title.includes('åè©') ||
          result.value.title.includes('å½¢å®¹è©') ||
          result.value.title.includes('ç‰¹æ®Š')
        ) {
          answerValue = textTaskAnswer.value
          extraPoints = 1
          taskFeedback.value = 'æ„Ÿè¬ä½ å®Œæˆä»Šå¤©çš„å­¸ç¿’ä»»å‹™ï¼'
        } else if (result.value.title.includes('é›™ä¸ƒ')) {
          // å•ç­”é¡Œé©—è­‰
          answerValue = radioTaskAnswer.value
          correct = radioTaskAnswer.value === bonusCorrectAnswer.value
          extraPoints = correct ? 2 : 0
          taskFeedback.value = correct
            ? 'ç­”å°äº†ï¼ç²å¾—é¡å¤–çš„çå‹µé»æ•¸ï¼'
            : `ç­”éŒ¯äº†ï¼æ­£ç¢ºç­”æ¡ˆæ˜¯ ${bonusCorrectAnswer.value}`
        } else if (result.value.title.includes('å¹¸é‹')) {
          answerValue = checkboxTaskAnswer.value ? 'å·²é–±è®€' : 'æœªé–±è®€'
          extraPoints = 1
          taskFeedback.value = 'æ„Ÿè¬ä½ å®Œæˆä»Šå¤©çš„å­¸ç¿’ä»»å‹™ï¼'
        } else {
          // å…¶ä»–ä»»å‹™
          extraPoints = 1
          taskFeedback.value = 'æ„Ÿè¬ä½ å®Œæˆä»Šå¤©çš„å­¸ç¿’ä»»å‹™ï¼'
        }

        // è¨˜éŒ„ä»»å‹™å®Œæˆ - å®¢æˆ¶ç«¯æœ¬åœ°ä¿å­˜
        const taskData = {
          taskType: getTaskType(),
          answer: String(answerValue),
          correct: correct,
          points: result.value.points + extraPoints,
          timestamp: new Date().toISOString(),
        }

        // åœ¨æœ¬åœ°ä¿å­˜ä»»å‹™è¨˜éŒ„ï¼Œæš«æ™‚é¿é–‹Firebaseæ¬Šé™å•é¡Œ
        console.log('ä»»å‹™å®Œæˆè¨˜éŒ„:', taskData)

        // æ›´æ–°å®¢æˆ¶ç«¯ç‹€æ…‹ï¼Œé¡¯ç¤ºä»»å‹™å·²å®Œæˆ
        taskCompleted.value = true

        // å˜—è©¦æ›´æ–°Firebaseï¼Œä½†å³ä½¿å¤±æ•—ä¹Ÿä¸å½±éŸ¿ç”¨æˆ¶é«”é©—
        try {
          // åƒ…å˜—è©¦æ›´æ–°ç”¨æˆ¶ç©åˆ†ï¼Œé¿é–‹å¯«å…¥æ–°æ–‡æª”
          const userRef = dbRef(db, `users/${props.uid}`)
          const userSnapshot = await get(userRef)

          if (userSnapshot.exists()) {
            const userData = userSnapshot.val()
            const currentPoints = userData.points || 0
            const newPoints = currentPoints + (result.value.points + extraPoints)

            // åªæ›´æ–°ç©åˆ†å­—æ®µï¼Œä¸æ–°å¢æ–‡æª”
            await set(dbRef(db, `users/${props.uid}/points`), newPoints)
          }

          // å˜—è©¦ä¿å­˜ä»»å‹™è¨˜éŒ„ï¼Œä½†ä¸å½±éŸ¿ç”¨æˆ¶é«”é©—
          try {
            const taskRecordsRef = dbRef(db, `userTasks/${props.uid}`)
            await push(taskRecordsRef, taskData)
          } catch (recordError) {
            console.log('ä¿å­˜ä»»å‹™è¨˜éŒ„å¤±æ•—ï¼Œä½†ç”¨æˆ¶é«”é©—ä¸å—å½±éŸ¿:', recordError)
          }
        } catch (pointsError) {
          console.log('æ›´æ–°ç©åˆ†å¤±æ•—ï¼Œç”¨æˆ¶é«”é©—ä¸å—å½±éŸ¿:', pointsError)
        }
      } catch (error) {
        console.error('æäº¤ä»»å‹™å¤±æ•—:', error)
        // æä¾›æ›´å‹å¥½çš„éŒ¯èª¤è¨Šæ¯ï¼Œä½†ä»ç„¶è®“ç”¨æˆ¶å®Œæˆä»»å‹™
        if (error instanceof Error) {
          console.log(`æäº¤ä»»å‹™éŒ¯èª¤: ${error.message}ã€‚ä½†ä»»å‹™ä»æ¨™è¨˜ç‚ºå®Œæˆã€‚`)
        }

        // å³ä½¿æœ‰éŒ¯èª¤ï¼Œä¹Ÿå°‡ä»»å‹™æ¨™è¨˜ç‚ºå®Œæˆ
        taskCompleted.value = true
        taskFeedback.value = 'æ‚¨çš„ç­”æ¡ˆå·²è¨˜éŒ„ï¼è³‡æ–™åŒæ­¥å¯èƒ½åœ¨ç¨å¾Œå®Œæˆã€‚'
      }
    }

    // ç²å–ä»»å‹™é¡å‹
    const getTaskType = (): string => {
      if (!result.value) return 'unknown'

      if (result.value.title.includes('å‹•è©')) return 'verb'
      if (result.value.title.includes('åè©')) return 'noun'
      if (result.value.title.includes('å½¢å®¹è©')) return 'adjective'
      if (result.value.title.includes('ç‰¹æ®Š')) return 'special'
      if (result.value.title.includes('é›™ä¸ƒ')) return 'bonus'
      if (result.value.title.includes('å¹¸é‹')) return 'knowledge'

      return 'unknown'
    }

    // å„²å­˜éŠæˆ²è¨˜éŒ„
    const saveGameRecord = async (symbols: Symbol[], points: number) => {
      if (props.uid === '') return

      const db = getDatabase()

      try {
        // å„²å­˜éŠæˆ²è¨˜éŒ„
        const gameRecordsRef = dbRef(db, `gameRecords/${props.uid}`)
        const newRecordRef = push(gameRecordsRef)
        await set(newRecordRef, {
          symbols: symbols.map((s) => ({
            type: s.type,
            value: s.value,
            emoji: s.emoji,
            category: s.category,
            text: s.text,
          })),
          points: points,
          timestamp: serverTimestamp(),
        })

        // æ›´æ–°ç”¨æˆ¶ç©åˆ†
        const userRef = dbRef(db, `users/${props.uid}`)
        const userSnapshot = await get(userRef)
        const currentPoints = userSnapshot.exists() ? userSnapshot.val().points || 0 : 0
        await set(dbRef(db, `users/${props.uid}/points`), currentPoints + points)

        // æ–°å¢é€šçŸ¥
        const notificationsRef = dbRef(db, `users/${props.uid}/notifications`)
        const newNotificationRef = push(notificationsRef)
        await set(newNotificationRef, {
          type: 'gameResult',
          message: `æ‹‰éœ¸çµæœï¼š${result.value?.title}ï¼Œç²å¾— ${points} é»ï¼`,
          timestamp: serverTimestamp(),
          read: false,
        })
      } catch (error) {
        console.error('å„²å­˜éŠæˆ²è¨˜éŒ„å¤±æ•—:', error)
      }
    }

    // å¼·åˆ¶é‡ç¹ª
    const forceRedraw = () => {
      console.log('æ‰‹å‹•è§¸ç™¼é‡ç¹ª')

      // é‡æ–°åˆå§‹åŒ–Canvas
      if (slotCanvas.value) {
        ctx.value = slotCanvas.value.getContext('2d')

        // æª¢æŸ¥è½‰è¼ªæ˜¯å¦æœ‰ç¬¦è™Ÿ
        for (let i = 0; i < reels.value.length; i++) {
          const reel = reels.value[i]
          if (reel && reel.symbols.length === 0) {
            reel.symbols = [...symbols].sort(() => Math.random() - 0.5)
            reel.position = Math.floor(Math.random() * reel.symbols.length)
            console.log(`é‡æ–°åˆå§‹åŒ–è½‰è¼ª ${i} çš„ç¬¦è™Ÿ`)
          }
        }

        // é‡ç¹ªç•«é¢
        drawSlotMachine()
      } else {
        console.error('Canvaså…ƒç´ ä¸å­˜åœ¨ï¼Œç„¡æ³•é‡ç¹ª')
      }
    }

    const toggleLogin = () => {
      emit('toggleLogin')
    }

    // åˆå§‹åŒ–é é¢
    onMounted(() => {
      console.log('é–‹å§‹åˆå§‹åŒ–é é¢')
      let retryCount = 0
      const maxRetries = 5

      const tryInitCanvas = () => {
        if (slotCanvas.value) {
          console.log('æ‰¾åˆ°Canvaså…ƒç´ ï¼Œé–‹å§‹åˆå§‹åŒ–')
          initCanvas()
        } else if (retryCount < maxRetries) {
          retryCount++
          console.log(`Canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œç¬¬ ${retryCount} æ¬¡é‡è©¦`)
          setTimeout(tryInitCanvas, 200)
        } else {
          console.error('Canvaså…ƒç´ åˆå§‹åŒ–å¤±æ•—ï¼Œå·²é”æœ€å¤§é‡è©¦æ¬¡æ•¸')
        }
      }

      tryInitCanvas()
      updateCanvasSize()
      window.addEventListener('resize', updateCanvasSize)
    })

    // æ¸…ç†è³‡æº
    onUnmounted(() => {
      window.removeEventListener('resize', updateCanvasSize)
    })

    watch(
      () => props.uid,
      (newUid) => {
        console.log('uid changed:', newUid)
        if (newUid !== '') {
          // å¦‚æœuidæœ‰å€¼ï¼Œå‰‡é‡ç¹ªç•«é¢
          initCanvas()
          forceRedraw()
        }
      },
    )

    return {
      slotCanvas,
      canPlay,
      spinning,
      leverPulled,
      result,
      pullLever,
      forceRedraw,
      textTaskAnswer,
      radioTaskAnswer,
      checkboxTaskAnswer,
      taskCompleted,
      taskFeedback,
      specialCombinationSentence,
      bonusQuestion,
      bonusOptions,
      bonusCorrectAnswer,
      knowledgeCard,
      isTaskAnswerValid,
      submitTask,
      useDefaultBonusQuestion,
      useDefaultKnowledgeCard,
      showRules,
      canvasWidth,
      canvasHeight,
      toggleLogin,
    }
  },
})
</script>

<style scoped>
.page-title {
  color: #1a1a1a;
  font-weight: 700;
  letter-spacing: -0.5px;
  text-align: center;
  padding: 0 16px;
  font-size: clamp(1.5rem, 5vw, 2rem);
}

.login-container {
  background-color: white;
  border-radius: 16px;
  width: 100%;
  max-width: 400px;
  border: 1px solid #e6e6eb;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.slot-machine-container {
  position: relative;
  width: 100%;
  max-width: 600px;
  aspect-ratio: 3/2;
  background-color: #f5f5f7;
  padding: 0;
  border-radius: 16px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible;
  border: 1px solid #e6e6eb;
}

.slot-canvas {
  display: block;
  width: 100%;
  height: 100%;
  border-radius: 12px;
  z-index: 10;
  position: relative;
}

.slot-lever {
  position: absolute;
  right: -30px;
  top: 50%;
  transform: translateY(-50%);
  cursor: pointer;
  transition: transform 0.3s ease;
  z-index: 15;
}

.lever-grip {
  width: 30px;
  height: 30px;
  background-color: #0070ff;
  border-radius: 50%;
  margin-bottom: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.lever-stick {
  width: 8px;
  height: 60px;
  background-color: #1a84ff;
  margin: 0 auto;
  border-radius: 5px;
}

.lever-base {
  width: 32px;
  height: 12px;
  background-color: #0070ff;
  border-radius: 5px;
  margin-top: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.lever-pulled {
  transform: rotate(30deg);
}

.result-container {
  margin-top: 20px;
  padding: 24px;
  background-color: white;
  border-radius: 16px;
  width: 600px;
  border: 1px solid #e6e6eb;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.result-title {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 12px;
  color: #1a1a1a;
}

.result-description {
  font-size: 16px;
  margin-bottom: 16px;
  color: #404040;
  line-height: 1.5;
}

.task-container {
  background-color: #f5f8ff;
  padding: 16px;
  border-radius: 12px;
  margin-bottom: 16px;
  border-left: 4px solid #0070ff;
}

.task-input-container {
  margin-top: 16px;
}

.task-instruction {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #1a1a1a;
}

.task-input {
  width: 100%;
  padding: 12px;
  border: 1px solid #e6e6eb;
  border-radius: 8px;
}

.task-actions {
  text-align: right;
}

.task-completed-container {
  text-align: center;
}

.task-completed-message {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #1a1a1a;
}

.task-feedback {
  font-size: 16px;
  color: #404040;
}

.knowledge-card {
  background-color: #f0f7ff;
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
  border-left: 4px solid #0070ff;
}

.knowledge-title {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 12px;
  color: #1a1a1a;
}

.knowledge-content {
  font-size: 16px;
  line-height: 1.5;
  color: #404040;
  margin-bottom: 12px;
}

.knowledge-tip {
  font-size: 15px;
  font-style: italic;
  color: #0070ff;
}

.translation-text {
  font-size: 18px;
  background-color: rgba(0, 112, 255, 0.1);
  padding: 12px;
  border-radius: 8px;
  color: #0070ff;
  font-weight: 500;
  margin-bottom: 16px;
}

.bonus-options {
  display: flex;
  flex-direction: column;
  margin-top: 16px;
  margin-bottom: 16px;
}

.points-container {
  font-size: 18px;
  font-weight: 600;
  color: #0070ff;
}

.q-btn {
  text-transform: none;
  font-weight: 600;
  letter-spacing: 0.3px;
}

/* AT Protocol inspired color palette */
:deep(.q-btn.primary) {
  background: #0070ff !important;
}

:deep(.q-btn.secondary) {
  background: #8e8e93 !important;
}

/* éŠæˆ²è¦å‰‡æ¨£å¼ */
.rules-container {
  background-color: white;
  border-radius: 16px;
  padding: 24px;
  width: 600px;
  margin-bottom: 20px;
  border: 1px solid #e6e6eb;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.rules-title {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 16px;
  color: #1a1a1a;
  border-bottom: 2px solid #0070ff;
  padding-bottom: 8px;
}

.rules-content {
  font-size: 15px;
  color: #404040;
  line-height: 1.5;
}

.rules-section {
  margin: 16px 0;
}

.rules-subtitle {
  font-size: 17px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #0070ff;
}

.rules-tip {
  font-size: 15px;
  font-style: italic;
  color: #0070ff;
  background-color: rgba(0, 112, 255, 0.05);
  padding: 10px;
  border-radius: 8px;
  margin-top: 16px;
}

.combinations-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
  gap: 12px;
  margin-top: 12px;
}

.combination-card {
  background-color: #f5f8ff;
  border-radius: 8px;
  padding: 12px;
  border-left: 3px solid #0070ff;
}

.combination-title {
  font-weight: 600;
  font-size: 15px;
  margin-bottom: 6px;
  color: #1a1a1a;
}

.combination-example {
  font-size: 13px;
  color: #666;
  margin-bottom: 6px;
  font-style: italic;
}

.combination-task {
  font-size: 13px;
  color: #404040;
  margin-bottom: 6px;
}

.combination-points {
  font-weight: 600;
  color: #0070ff;
  font-size: 14px;
}

.action-buttons {
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: 100%;
  max-width: 600px;
}

.action-button {
  width: 100%;
}

@media (max-width: 600px) {
  .slot-lever {
    right: -20px;
  }

  .lever-grip {
    width: 24px;
    height: 24px;
  }

  .lever-stick {
    width: 8px;
    height: 60px;
  }

  .lever-base {
    width: 32px;
    height: 12px;
  }

  .result-container {
    width: 100%;
    max-width: 600px;
    padding: 16px;
  }

  .rules-container {
    width: 100%;
    max-width: 600px;
    padding: 16px;
  }

  .action-buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    max-width: 600px;
  }

  .action-button {
    width: 100%;
  }
}
</style>
